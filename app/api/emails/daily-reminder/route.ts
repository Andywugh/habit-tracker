import { NextRequest, NextResponse } from "next/server";
import { Resend } from "resend";
import { createClient } from "@supabase/supabase-js";
import DailyReminderEmail from "../../../../emails/DailyReminderEmail";

// Create admin client for service role operations
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
);

const resend = new Resend(process.env.RESEND_API_KEY);
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// POST /api/emails/daily-reminder - å‘é€æ—¥å¸¸æé†’é‚®ä»¶
export async function POST(request: NextRequest) {
  try {
    let user;
    let userId;
    
    // Check if using service role key authentication
    const authHeader = request.headers.get('authorization');
    const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
    
    if (authHeader && authHeader === `Bearer ${serviceRoleKey}`) {
      // Service role authentication - get user_id from request body
      const body = await request.json();
      userId = body.user_id;
      
      if (!userId) {
        return NextResponse.json(
          { error: 'Missing user_id in request body for service role authentication' },
          { status: 400 }
        );
      }
      
      // Use admin client to get user by ID
      const { data: userData, error: userError } = await supabaseAdmin.auth.admin.getUserById(userId);
      
      if (userError || !userData.user) {
        return NextResponse.json(
          { error: 'User not found' },
          { status: 404 }
        );
      }
      
      user = userData.user;
    } else if (authHeader && authHeader.startsWith('Bearer ')) {
      // Regular user token authentication
      const token = authHeader.split(' ')[1];
      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser(token);
      
      if (authError || !authUser) {
        return NextResponse.json(
          { error: 'Invalid token' },
          { status: 401 }
        );
      }
      
      user = authUser;
      userId = user.id;
    } else {
      return NextResponse.json(
        { error: 'Missing or invalid authorization header' },
        { status: 401 }
      );
    }

    // Use appropriate client based on authentication method
    const dbClient = authHeader && authHeader === `Bearer ${serviceRoleKey}` ? supabaseAdmin : supabase;

    // è·å–ç”¨æˆ·èµ„æ–™
    const { data: profile } = await dbClient
      .from("user_profiles")
      .select("*")
      .eq("id", userId)
      .single();

    // è·å–ç”¨æˆ·é€šçŸ¥è®¾ç½®
    const { data: notificationSettings } = await dbClient
      .from("user_notification_settings")
      .select("*")
      .eq("user_id", userId)
      .single();

    // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†æ—¥å¸¸æé†’
    if (notificationSettings && !notificationSettings.daily_reminder) {
      return NextResponse.json({
        success: true,
        message: "Daily reminder is disabled for this user",
        skipped: true
      });
    }

    // è·å–ç”¨æˆ·çš„ä¹ æƒ¯
    const { data: habits, error: habitsError } = await dbClient
      .from("habits")
      .select(`
        id,
        name,
        frequency,
        created_at
      `)
      .eq("user_id", userId)
      .eq("is_active", true)
      .order("created_at", { ascending: true });

    if (habitsError) {
      return NextResponse.json(
        { success: false, error: "Failed to fetch habits" },
        { status: 500 }
      );
    }

    if (!habits || habits.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No active habits found for user",
        skipped: true
      });
    }

    // è·å–ä»Šå¤©çš„æ—¥æœŸ
    const today = new Date();
    const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const todayEnd = new Date(todayStart);
    todayEnd.setDate(todayEnd.getDate() + 1);

    // è·å–ä»Šå¤©çš„ä¹ æƒ¯è®°å½•
    const { data: todayLogs } = await dbClient
      .from("habit_logs")
      .select("habit_id, completed_at")
      .eq("user_id", userId)
      .gte("completed_at", todayStart.toISOString())
      .lt("completed_at", todayEnd.toISOString());

    // è®¡ç®—æ¯ä¸ªä¹ æƒ¯çš„è¿ç»­å¤©æ•°
    const habitsWithStreaks = await Promise.all(
      habits.map(async (habit) => {
        // è·å–è¯¥ä¹ æƒ¯çš„æ‰€æœ‰è®°å½•ï¼ŒæŒ‰å®Œæˆæ—¶é—´å€’åº
        const { data: logs } = await dbClient
          .from("habit_logs")
          .select("completed_at")
          .eq("habit_id", habit.id)
          .eq("user_id", userId)
          .order("completed_at", { ascending: false });

        // è®¡ç®—è¿ç»­å¤©æ•° - ç®€åŒ–ç‰ˆæœ¬ï¼Œåªè®¡ç®—æ€»è®°å½•æ•°ä½œä¸º"è¿ç»­å¤©æ•°"
        let streak = 0;
        if (logs && logs.length > 0) {
          // è·å–æœ€è¿‘7å¤©çš„è®°å½•æ¥è®¡ç®—è¿ç»­å¤©æ•°
          const recentLogs = logs.slice(0, 7);
          const today = new Date();
          
          for (let i = 0; i < 7; i++) {
            const checkDate = new Date(today);
            checkDate.setDate(today.getDate() - i);
            const checkDateStart = new Date(checkDate.getFullYear(), checkDate.getMonth(), checkDate.getDate());
            const checkDateEnd = new Date(checkDateStart);
            checkDateEnd.setDate(checkDateEnd.getDate() + 1);
            
            const hasLogForDay = logs.some(log => {
              const logDate = new Date(log.completed_at);
              return logDate >= checkDateStart && logDate < checkDateEnd;
            });
            
            if (hasLogForDay) {
              streak++;
            } else {
              break;
            }
          }
        }

        // æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²å®Œæˆ
        const todayLog = todayLogs?.find(log => log.habit_id === habit.id);
        const isCompleted = !!todayLog;

        return {
          id: habit.id,
          name: habit.name,
          description: '', // æš‚æ—¶ä¸ºç©ºï¼Œå› ä¸ºæ•°æ®åº“ä¸­æ²¡æœ‰è¿™ä¸ªå­—æ®µ
          streak,
          isCompleted
        };
      })
    );

    // è¿‡æ»¤å‡ºä»Šå¤©éœ€è¦æ‰§è¡Œçš„ä¹ æƒ¯ï¼ˆæ ¹æ®é¢‘ç‡ï¼‰
    const todayHabits = habitsWithStreaks.filter(habit => {
      const habitData = habits.find(h => h.id === habit.id);
      if (!habitData?.frequency) return true; // é»˜è®¤æ¯æ—¥
      
      const frequency = habitData.frequency;
      if (frequency.type === 'daily') return true;
      
      if (frequency.type === 'weekly' && frequency.days) {
        const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, ...
        return frequency.days.includes(dayOfWeek);
      }
      
      return true; // é»˜è®¤åŒ…å«
    });

    if (todayHabits.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No habits scheduled for today",
        skipped: true
      });
    }

    // å‘é€é‚®ä»¶
    const { data, error } = await resend.emails.send({
      from: "ä¹ æƒ¯æé†’ <onboarding@resend.dev>", // ä½¿ç”¨Resendçš„æµ‹è¯•åŸŸå
      to: [user.email!],
      subject: `ğŸŒ… ${profile?.name || "ç”¨æˆ·"}ï¼Œæ–°çš„ä¸€å¤©å¼€å§‹äº†ï¼`,
      text: `æ—©å®‰ï¼Œ${profile?.name || "ç”¨æˆ·"}ï¼

æ–°çš„ä¸€å¤©å¼€å§‹äº†ï¼è®©æˆ‘ä»¬ä¸€èµ·å›é¡¾ä»Šå¤©çš„ä¹ æƒ¯ç›®æ ‡å§ã€‚

ä»Šå¤©çš„ä¹ æƒ¯ï¼š
${todayHabits.map(h => `${h.isCompleted ? 'âœ…' : 'â°'} ${h.name}${h.streak > 0 ? ` (è¿ç»­${h.streak}å¤©)` : ''}`).join('\n')}

${todayHabits.filter(h => !h.isCompleted).length > 0 ? 
  `è¿˜æœ‰ ${todayHabits.filter(h => !h.isCompleted).length} ä¸ªä¹ æƒ¯å¾…å®Œæˆï¼Œç»§ç»­åŠ æ²¹ï¼` : 
  'å¤ªæ£’äº†ï¼ä»Šå¤©çš„æ‰€æœ‰ä¹ æƒ¯éƒ½å·²å®Œæˆï¼'
}

ğŸ’ª æ¯ä¸€ä¸ªå°ä¹ æƒ¯éƒ½æ˜¯é€šå‘æ›´å¥½è‡ªå·±çš„ä¸€æ­¥

æ¥è‡ªä½ çš„ä¹ æƒ¯è¿½è¸ªå™¨`,
    });

    if (error) {
      console.error("Resend email error:", error);
      return NextResponse.json(
        { success: false, error: `Email sending failed: ${error.message}` },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: "Daily reminder email sent successfully",
      data: {
        emailId: data?.id,
        habitsCount: todayHabits.length,
        completedCount: todayHabits.filter(h => h.isCompleted).length,
        pendingCount: todayHabits.filter(h => !h.isCompleted).length
      }
    });

  } catch (error) {
    console.error("Daily reminder email error:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Internal server error",
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}